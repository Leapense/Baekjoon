<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Mall Mania: ìµœë‹¨ ë³´í–‰ ê±°ë¦¬ BFS ì‹œê°í™”</title>
    <style>
        :root {
            --bg: #0b1020;
            --panel: #0f1630;
            --ink: #e6ecff;
            --muted: #92a0c6;
            --accent: #8cf;
            --accent2: #f6a;
            --ok: #8f8;
            --warn: #fd6;
            --danger: #f88;
        }

        * {
            box-sizing: border-box;
        }

        html,
        body {
            height: 100%;
        }

        body {
            margin: 0;
            display: grid;
            grid-template-rows: auto 1fr auto;
            gap: 10px;
            background: var(--bg);
            color: var(--ink);
            font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
        }

        header {
            padding: 12px 16px;
            display: flex;
            align-items: center;
            gap: 14px;
            background: linear-gradient(180deg, #121938, #0e152f);
            border-bottom: 1px solid #1c2758;
        }

        header h1 {
            margin: 0;
            font-size: 18px;
            font-weight: 700;
            letter-spacing: 0.2px;
        }

        main {
            display: grid;
            grid-template-columns: 420px 1fr;
            gap: 12px;
            padding: 0 12px 12px;
        }

        .panel {
            background: var(--panel);
            border: 1px solid #1b2552;
            border-radius: 14px;
            box-shadow: 0 6px 18px rgba(0, 0, 0, 0.35), inset 0 1px 0 rgba(255, 255, 255, 0.05);
        }

        .left {
            display: grid;
            grid-template-rows: auto auto 1fr;
            overflow: hidden;
        }

        .section {
            padding: 12px 14px;
            border-bottom: 1px dashed #21306b;
        }

        .section:last-child {
            border-bottom: none;
        }

        .controls {
            display: grid;
            grid-template-columns: 1fr;
            gap: 10px;
        }

        textarea {
            width: 100%;
            min-height: 140px;
            resize: vertical;
            border-radius: 10px;
            border: 1px solid #29356e;
            background: #0b122b;
            color: var(--ink);
            padding: 10px;
            font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
        }

        .btns {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        button,
        .pill {
            background: #101a3e;
            color: var(--ink);
            border: 1px solid #2a3a79;
            border-radius: 999px;
            padding: 8px 12px;
            cursor: pointer;
            font-weight: 600;
            transition: transform .05s ease, background .2s ease, box-shadow .2s ease;
            box-shadow: 0 4px 10px rgba(0, 0, 0, .2), inset 0 1px 0 rgba(255, 255, 255, .03);
        }

        button:hover {
            background: #132053;
        }

        button:active {
            transform: translateY(1px);
        }

        button[disabled] {
            opacity: .5;
            cursor: not-allowed;
        }

        .kv {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 4px 8px;
            font-feature-settings: "tnum" 1;
        }

        .kv .muted {
            color: var(--muted);
        }

        .row {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        label {
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        input[type="number"],
        input[type="range"] {
            width: 130px;
        }

        input[type="checkbox"] {
            transform: translateY(1px);
        }

        .legend {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .dot {
            width: 12px;
            height: 12px;
            border-radius: 2px;
            display: inline-block;
            vertical-align: middle;
        }

        .dotA {
            background: #6cf;
            border: 1px solid #9de;
        }

        .dotB {
            background: #f96;
            border: 1px solid #fc9;
        }

        .dotFront {
            background: #9f9;
            border: 1px solid #cfc;
        }

        .dotVisited {
            background: #445a3b;
            border: 1px solid #5f7a55;
        }

        .dotPath {
            background: #ffdd55;
            border: 1px solid #ffe58a;
        }

        .viz {
            position: relative;
            padding: 12px;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            border-radius: 12px;
            background: #0a0f22;
            border: 1px solid #1b2552;
        }

        .hud {
            position: absolute;
            left: 20px;
            top: 20px;
            background: rgba(7, 10, 25, 0.78);
            border: 1px solid #1e2a5e;
            border-radius: 10px;
            padding: 10px 12px;
            backdrop-filter: blur(4px);
        }

        .hud h3 {
            margin: 0 0 6px;
            font-size: 13px;
            color: var(--muted);
            font-weight: 700;
            letter-spacing: .2px;
        }

        .hud table {
            border-collapse: collapse;
        }

        .hud td {
            padding: 2px 6px;
            font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
        }

        .hud td:first-child {
            color: var(--muted);
        }

        footer {
            padding: 10px 14px;
            color: var(--muted);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .subtle {
            color: var(--muted);
            font-size: 12px;
        }
    </style>
</head>

<body>
    <header>
        <h1>ğŸ§­ Mall Mania â€” ê²½ê³„â†”ê²½ê³„ ìµœë‹¨ ë³´í–‰ ê±°ë¦¬ (BFS) ì‹œê°í™”</h1>
        <span class="subtle">ë‹¤ì›ë°œ BFSë¡œ ë‘ ëª°ì˜ ê²½ê³„ì  ì‚¬ì´ ë§¨í•´íŠ¼ ìµœì†Œ ê±°ë¦¬ë¥¼ íƒìƒ‰í•©ë‹ˆë‹¤.</span>
    </header>

    <main>
        <section class="panel left">
            <div class="section">
                <div class="controls">
                    <div class="row">
                        <div class="legend">
                            <span class="pill">ë²”ë¡€</span>
                            <span><span class="dot dotA"></span> ëª° A ê²½ê³„</span>
                            <span><span class="dot dotB"></span> ëª° B ê²½ê³„</span>
                            <span><span class="dot dotFront"></span> ìµœì‹  í”„ë¡ í‹°ì–´</span>
                            <span><span class="dot dotVisited"></span> ëˆ„ì  ë°©ë¬¸</span>
                            <span><span class="dot dotPath"></span> í•œ ê²½ë¡œ</span>
                        </div>
                    </div>
                    <textarea id="input" spellcheck="false"
                        placeholder="ì—¬ê¸°ì— ì…ë ¥ì„ ë¶™ì—¬ë„£ìœ¼ì„¸ìš”. ì˜ˆ:&#10;4&#10;0 0 0 1 1 1 1 0&#10;6&#10;4 3 4 2 3 2&#10;2 2 2 3&#10;3 3&#10;0"></textarea>
                    <div class="btns">
                        <button id="btnSample">ìƒ˜í”Œ ì…ë ¥ ì±„ìš°ê¸°</button>
                        <button id="btnInit">íŒŒì‹± & ì´ˆê¸°í™”</button>
                        <button id="btnStep">í•œ ë‹¨ê³„</button>
                        <button id="btnRun">ìë™ ì¬ìƒ â–¶</button>
                        <button id="btnPause" disabled>ì¼ì‹œì •ì§€ â¸</button>
                        <button id="btnReset">ë¦¬ì…‹</button>
                    </div>
                    <div class="row">
                        <label>í‹±ë‹¹ í™•ì¥ ë…¸ë“œ: <input type="range" id="rngBatch" min="100" max="20000" step="100"
                                value="2000"> <span id="lblBatch">2000</span></label>
                    </div>
                    <div class="row">
                        <label><input type="checkbox" id="chkAutoZoom" checked> ìë™ ì¤Œ</label>
                        <label><input type="checkbox" id="chkGrid"> ê²©ìì„ </label>
                        <label><input type="checkbox" id="chkAccumulate"> ë°©ë¬¸ ëˆ„ì  í‘œì‹œ</label>
                        <label><input type="checkbox" id="chkShowPath" checked> ê²½ë¡œ í‘œì‹œ</label>
                    </div>
                </div>
            </div>

            <div class="section">
                <div class="kv">
                    <div class="muted">í•´ê²° ì „ëµ</div>
                    <div>ëª° Aì˜ ëª¨ë“  ê²½ê³„ì ì„ ì‹œì‘ì ìœ¼ë¡œ, 4ë°©í–¥ ê²©ìì—ì„œ ë‹¤ì›ë°œ BFSë¥¼ ìˆ˜í–‰í•˜ì—¬ ëª° B ê²½ê³„ì— ìµœì´ˆë¡œ ë‹¿ëŠ” ë ˆë²¨ì´ ì •ë‹µì…ë‹ˆë‹¤. ë‚´ë¶€ì—ì„œ ì¶œë°œí•˜ëŠ” ìµœë‹¨ ê²½ë¡œëŠ” ë°˜ë“œì‹œ ì–´ë–¤
                        ê²½ê³„ì ì„ ê±°ì¹˜ë¯€ë¡œ ê²½ê³„â†”ê²½ê³„ë§Œ ë³´ë©´ ì¶©ë¶„í•©ë‹ˆë‹¤.</div>
                    <div class="muted">ì¢Œí‘œ ë²”ìœ„</div>
                    <div>0..2000 (ê°€ë¡œ: Avenue x, ì„¸ë¡œ: Street y)</div>
                    <div class="muted">ë³µì¡ë„</div>
                    <div>ì‹œê°„ O(ë°©ë¬¸ ê²©ììˆ˜), ê³µê°„ â‰ˆ 2Ã—2001Â² ë°”ì´íŠ¸ + (ì„ íƒ) ê²½ë¡œ ì¶”ì </div>
                </div>
            </div>

            <div class="section">
                <div class="kv">
                    <div class="muted">ì…ë ¥ í˜•ì‹</div>
                    <div>pâ‚, pâ‚ìŒì˜ (a,s), pâ‚‚, pâ‚‚ìŒì˜ (a,s). ì—¬ê¸°ì„œëŠ” í•œ í…ŒìŠ¤íŠ¸ì¼€ì´ìŠ¤ë§Œ ì‹œê°í™”í•©ë‹ˆë‹¤.</div>
                    <div class="muted">íŒ</div>
                    <div>ìë™ ì¬ìƒì€ ë§¤ í‹±ë§ˆë‹¤ ì •í•´ì§„ ê°œìˆ˜ì˜ ë…¸ë“œë¥¼ í™•ì¥í•©ë‹ˆë‹¤. í° ì¢Œí‘œì—ì„œëŠ” ëˆ„ì  í‘œì‹œë¥¼ ë„ê³  í”„ë¡ í‹°ì–´ë§Œ ë³´ì„¸ìš”.</div>
                </div>
            </div>
        </section>

        <section class="panel viz" id="vizPanel">
            <canvas id="cv" width="1100" height="800"></canvas>
            <div class="hud">
                <h3>ìƒíƒœ</h3>
                <table>
                    <tr>
                        <td>ê±°ë¦¬ d</td>
                        <td id="statDist">-</td>
                    </tr>
                    <tr>
                        <td>í”„ë¡ í‹°ì–´</td>
                        <td id="statFrontier">-</td>
                    </tr>
                    <tr>
                        <td>ë°©ë¬¸ ìˆ˜</td>
                        <td id="statVisited">-</td>
                    </tr>
                    <tr>
                        <td>í ê¸¸ì´</td>
                        <td id="statQLen">-</td>
                    </tr>
                    <tr>
                        <td>ì§„í–‰</td>
                        <td id="statPhase">ëŒ€ê¸°</td>
                    </tr>
                    <tr>
                        <td>ë·°í¬íŠ¸</td>
                        <td id="statView">-</td>
                    </tr>
                </table>
            </div>
        </section>
    </main>

    <footer>
        <div class="subtle">Â© Mall Mania Visualizer â€¢ BFS wavefront, multi-source â€¢ Made with vanilla HTML/CSS/JS</div>
        <div class="subtle">í…ŒìŠ¤íŠ¸ í•´ë³´ê³  ì‹¶ë‹¤ë©´ ìƒ˜í”Œ ì…ë ¥ â†’ íŒŒì‹± & ì´ˆê¸°í™” â†’ ìë™ ì¬ìƒ ìˆœì„œë¡œ ëˆŒëŸ¬ë³´ì„¸ìš”.</div>
    </footer>

    <script>
        (() => {
            const W = 2001, H = 2001; // ì¢Œí‘œ ë²”ìœ„ 0..2000
            const cv = document.getElementById('cv');
            const ctx = cv.getContext('2d');
            const ui = {
                input: document.getElementById('input'),
                btnSample: document.getElementById('btnSample'),
                btnInit: document.getElementById('btnInit'),
                btnStep: document.getElementById('btnStep'),
                btnRun: document.getElementById('btnRun'),
                btnPause: document.getElementById('btnPause'),
                btnReset: document.getElementById('btnReset'),
                rngBatch: document.getElementById('rngBatch'),
                lblBatch: document.getElementById('lblBatch'),
                chkAutoZoom: document.getElementById('chkAutoZoom'),
                chkGrid: document.getElementById('chkGrid'),
                chkAccumulate: document.getElementById('chkAccumulate'),
                chkShowPath: document.getElementById('chkShowPath'),
                stat: {
                    dist: document.getElementById('statDist'),
                    frontier: document.getElementById('statFrontier'),
                    visited: document.getElementById('statVisited'),
                    qlen: document.getElementById('statQLen'),
                    phase: document.getElementById('statPhase'),
                    view: document.getElementById('statView'),
                }
            };

            const colors = {
                bg: '#0a0f22',
                grid: '#162145',
                A: '#6cf',
                B: '#f96',
                frontier: '#9f9',
                visited: 'rgba(120,160,120,0.35)',
                path: '#ffdd55',
            };

            let state = null; // ì¬ì‹œì‘ ê°€ëŠ¥
            let animId = null;

            function setPhase(text) { ui.stat.phase.textContent = text; }
            function fmt(n) { return typeof n === 'number' ? n.toLocaleString('en-US') : n; }

            function sampleInput() {
                ui.input.value = `4\n0 0 0 1 1 1 1 0\n6\n4 3 4 2 3 2\n2 2 2 3\n3 3\n0`;
            }

            function parseInput(text) {
                // ëª¨ë“  ì •ìˆ˜ë¥¼ ì¶”ì¶œ
                const nums = text.trim().split(/\s+/).map(Number).filter(n => !Number.isNaN(n));
                if (nums.length < 1) throw new Error('ì…ë ¥ ë¶€ì¡±');

                let i = 0;
                const p1 = nums[i++];
                if (!(p1 >= 4)) throw new Error('p1(ì²« ëª° ë‘˜ë ˆ) >= 4 í•„ìš”');
                const A = [];
                for (let k = 0; k < p1; k++) { A.push({ x: nums[i++], y: nums[i++] }); }
                const p2 = nums[i++];
                if (!(p2 >= 4)) throw new Error('p2(ë‘˜ì§¸ ëª° ë‘˜ë ˆ) >= 4 í•„ìš”');
                const B = [];
                for (let k = 0; k < p2; k++) { B.push({ x: nums[i++], y: nums[i++] }); }
                return { A, B };
            }

            function initFromInput() {
                try {
                    const { A, B } = parseInput(ui.input.value);
                    reset();
                    state = makeState(A, B);
                    setPhase('ì¤€ë¹„ë¨');
                    draw();
                } catch (e) {
                    alert('íŒŒì‹± ì˜¤ë¥˜: ' + e.message);
                }
            }

            function makeState(Ain, Bin) {
                // ì¢Œí‘œ ìœ íš¨ì„± í•„í„°ë§ (0..2000)
                const A = Ain.filter(p => p.x >= 0 && p.x < W && p.y >= 0 && p.y < H);
                const B = Bin.filter(p => p.x >= 0 && p.x < W && p.y >= 0 && p.y < H);

                // B ê²½ê³„ ë¹„íŠ¸ë§µ
                const isB = new Uint8Array(W * H);
                let minX = 2000, minY = 2000, maxX = 0, maxY = 0;
                let minXB = 2000, minYB = 2000, maxXB = 0, maxYB = 0;
                for (const p of B) {
                    const idx = p.y * W + p.x; isB[idx] = 1;
                    if (p.x < minXB) minXB = p.x; if (p.x > maxXB) maxXB = p.x;
                    if (p.y < minYB) minYB = p.y; if (p.y > maxYB) maxYB = p.y;
                }
                for (const p of A) {
                    if (p.x < minX) minX = p.x; if (p.x > maxX) maxX = p.x;
                    if (p.y < minY) minY = p.y; if (p.y > maxY) maxY = p.y;
                }

                // ë°©ë¬¸/í
                const vis = new Uint8Array(W * H);
                const parent = new Int32Array(W * H); parent.fill(-1);
                const qx = []; const qy = []; let head = 0;

                // ì‹œë“œ ì‚½ì…
                let immediate = false;
                for (const p of A) {
                    const idx = p.y * W + p.x;
                    if (!vis[idx]) {
                        vis[idx] = 1;
                        qx.push(p.x); qy.push(p.y);
                        if (isB[idx]) { immediate = true; }
                    }
                }

                const bbox = {
                    minX: Math.min(minX, minXB), minY: Math.min(minY, minYB),
                    maxX: Math.max(maxX, maxXB), maxY: Math.max(maxY, maxYB)
                };

                return {
                    A, B, isB, vis, parent, qx, qy, head,
                    dist: 0, curLayerEnd: qx.length, found: immediate ? 0 : -1,
                    bbox,
                    drawAccumulated: new Set(),
                    meetIdx: -1,
                };
            }

            function step(batch = 2000) {
                if (!state) return;
                if (state.found >= 0) return; // ì´ë¯¸ ì¢…ë£Œ

                const dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]];
                let processed = 0;

                while (processed < batch && state.head < state.qx.length && state.found < 0) {
                    const x = state.qx[state.head];
                    const y = state.qy[state.head];
                    const baseIdx = y * W + x;
                    state.head++;
                    processed++;

                    for (const [dx, dy] of dirs) {
                        const nx = x + dx, ny = y + dy;
                        if (nx < 0 || nx >= W || ny < 0 || ny >= H) continue;
                        const nidx = ny * W + nx;
                        if (state.vis[nidx]) continue;
                        if (state.isB[nidx]) {
                            // ë„ì°©
                            state.found = state.dist + 1;
                            state.parent[nidx] = baseIdx;
                            state.meetIdx = nidx;
                            // íë¥¼ ë¹„ì›Œ ë¹ ë¥´ê²Œ ì¢…ë£Œ
                            state.qx.length = state.head; state.qy.length = state.head;
                            break;
                        }
                        state.vis[nidx] = 1;
                        state.parent[nidx] = baseIdx;
                        state.qx.push(nx); state.qy.push(ny);
                    }

                    if (state.head === state.curLayerEnd) {
                        state.curLayerEnd = state.qx.length;
                        state.dist++;
                    }
                }
            }

            function reconstructPath() {
                if (!state || state.meetIdx < 0) return [];
                let idx = state.meetIdx;
                const pts = [];
                while (idx >= 0) {
                    const y = Math.floor(idx / W), x = idx - y * W;
                    pts.push({ x, y });
                    idx = state.parent[idx];
                }
                return pts; // ê±°ê¾¸ë¡œ (Bâ†’A)
            }

            // ===== ë Œë”ë§ =====
            function computeView() {
                if (!state) return { minX: 0, minY: 0, maxX: 2000, maxY: 2000, s: 1, m: 16 };
                let { minX, minY, maxX, maxY } = state.bbox;
                if (!ui.chkAutoZoom.checked) { minX = 0; minY = 0; maxX = 2000; maxY = 2000; }

                // ì•½ê°„ì˜ ì—¬ë°±
                const margin = 2;
                minX = Math.max(0, minX - margin);
                minY = Math.max(0, minY - margin);
                maxX = Math.min(2000, maxX + margin);
                maxY = Math.min(2000, maxY + margin);

                const vw = (maxX - minX + 1);
                const vh = (maxY - minY + 1);
                const s = Math.min((cv.width - 40) / vw, (cv.height - 40) / vh);
                const m = 20;
                ui.stat.view.textContent = `[${minX},${minY}]â€“[${maxX},${maxY}] s=${s.toFixed(2)}`;
                return { minX, minY, maxX, maxY, s, m };
            }

            function drawGrid(view) {
                if (!ui.chkGrid.checked) return;
                const { minX, minY, maxX, maxY, s, m } = view;
                ctx.save();
                ctx.strokeStyle = colors.grid;
                ctx.lineWidth = 1;
                ctx.globalAlpha = 0.5;
                ctx.beginPath();
                for (let x = minX; x <= maxX; x++) {
                    const cx = m + (x - minX) * s + 0.5;
                    ctx.moveTo(cx, m);
                    ctx.lineTo(cx, cv.height - m);
                }
                for (let y = minY; y <= maxY; y++) {
                    const cy = cv.height - m - (y - minY + 1) * s + 0.5;
                    ctx.moveTo(m, cy);
                    ctx.lineTo(cv.width - m, cy);
                }
                ctx.stroke();
                ctx.restore();
            }

            function drawPoints(points, color, view) {
                const { minX, minY, s, m } = view;
                ctx.fillStyle = color;
                for (const p of points) {
                    const cx = m + (p.x - minX) * s;
                    const cy = cv.height - m - (p.y - minY + 1) * s;
                    ctx.fillRect(Math.round(cx), Math.round(cy), Math.max(1, Math.floor(s)), Math.max(1, Math.floor(s)));
                }
            }

            function drawBitmapIndices(idxs, color, view) {
                const { minX, minY, s, m } = view;
                ctx.fillStyle = color;
                for (const idx of idxs) {
                    const y = Math.floor(idx / W), x = idx - y * W;
                    const cx = m + (x - minX) * s;
                    const cy = cv.height - m - (y - minY + 1) * s;
                    ctx.fillRect(Math.round(cx), Math.round(cy), Math.max(1, Math.floor(s)), Math.max(1, Math.floor(s)));
                }
            }

            function draw() {
                ctx.fillStyle = colors.bg;
                ctx.fillRect(0, 0, cv.width, cv.height);

                const view = computeView();
                drawGrid(view);

                if (!state) return;

                // ëˆ„ì  ë°©ë¬¸ í‘œì‹œ (ì˜µì…˜)
                if (ui.chkAccumulate.checked) {
                    ctx.globalAlpha = 1.0;
                    drawBitmapIndices(state.drawAccumulated, colors.visited, view);
                }

                // ê²½ê³„ì ë“¤
                ctx.globalAlpha = 1;
                drawPoints(state.A, colors.A, view);
                drawPoints(state.B, colors.B, view);

                // ìµœì‹  í”„ë¡ í‹°ì–´: head..curLayerEnd-1
                ctx.globalAlpha = 1.0;
                const frontier = [];
                if (state.head < state.curLayerEnd) {
                    for (let i = state.head; i < state.curLayerEnd; i++) {
                        const x = state.qx[i], y = state.qy[i];
                        frontier.push({ x, y });
                        if (ui.chkAccumulate.checked) state.drawAccumulated.add(y * W + x);
                    }
                }
                drawPoints(frontier, colors.frontier, view);

                // ê²½ë¡œ í‘œì‹œ
                if (ui.chkShowPath.checked && state.found >= 0) {
                    const path = reconstructPath();
                    drawPoints(path, colors.path, view);
                }

                // HUD
                ui.stat.dist.textContent = state.found >= 0 ? state.found : state.dist + ' (ì§„í–‰ì¤‘)';
                ui.stat.frontier.textContent = fmt(Math.max(0, state.curLayerEnd - state.head));
                ui.stat.visited.textContent = fmt(countVisited(state.vis));
                ui.stat.qlen.textContent = fmt(state.qx.length - state.head);
                ui.stat.phase.textContent = state.found >= 0 ? 'ì™„ë£Œ' : (animId ? 'ìë™ ì¬ìƒ' : 'ëŒ€ê¸°');
            }

            function countVisited(vis) {
                // ë¹ ë¥¸ ê·¼ì‚¬ ëŒ€ì‹  ì •í™•íˆ: ì†Œí˜• ì…ë ¥ì´ë¯€ë¡œ ì¶©ë¶„
                let c = 0;
                for (let i = 0; i < vis.length; i++) if (vis[i]) c++;
                return c;
            }

            function tick() {
                const batch = Number(ui.rngBatch.value);
                step(batch);
                draw();
                if (state && state.found < 0) {
                    animId = requestAnimationFrame(tick);
                } else {
                    stop();
                }
            }

            function run() {
                if (!state) return;
                if (state.found >= 0) return; // ì´ë¯¸ ë
                if (!animId) {
                    animId = requestAnimationFrame(tick);
                    ui.btnRun.disabled = true;
                    ui.btnPause.disabled = false;
                }
            }

            function stop() {
                if (animId) cancelAnimationFrame(animId);
                animId = null;
                ui.btnRun.disabled = false;
                ui.btnPause.disabled = true;
            }

            function stepOnce() {
                if (!state) return;
                if (state.found >= 0) return;
                step(Number(ui.rngBatch.value));
                draw();
            }

            function reset() {
                stop();
                state = null;
                ctx.fillStyle = colors.bg; ctx.fillRect(0, 0, cv.width, cv.height);
                ui.stat.dist.textContent = '-';
                ui.stat.frontier.textContent = '-';
                ui.stat.visited.textContent = '-';
                ui.stat.qlen.textContent = '-';
                setPhase('ëŒ€ê¸°');
            }

            // ì´ë²¤íŠ¸
            ui.btnSample.addEventListener('click', sampleInput);
            ui.btnInit.addEventListener('click', initFromInput);
            ui.btnRun.addEventListener('click', run);
            ui.btnPause.addEventListener('click', stop);
            ui.btnStep.addEventListener('click', stepOnce);
            ui.btnReset.addEventListener('click', reset);
            ui.rngBatch.addEventListener('input', () => ui.lblBatch.textContent = ui.rngBatch.value);
            ui.chkAutoZoom.addEventListener('change', draw);
            ui.chkGrid.addEventListener('change', draw);
            ui.chkAccumulate.addEventListener('change', draw);
            ui.chkShowPath.addEventListener('change', draw);

            // ì´ˆê¸° UI
            sampleInput();
            ui.lblBatch.textContent = ui.rngBatch.value;
            draw();
        })();
    </script>
</body>

</html>